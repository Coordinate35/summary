| 作者 | 版本号 | 时间 |
| :--- | :--- | :--- |
| Coordinate35 | v1.0.0 | 2024-01-02 |

# 软件工程的理想主义

一提到软件、系统架构，大家可能想到是各种UML结构图。这几年的感受下来，架构的结构图只是结果，架构实质上是一堆逻辑（因果）。这里面就包含了大量:

1. 因为 xxx, 所以能 xxx
2. 因为 xxx，所以不能 xxx

所有的这些因为所以，组成了一个庞大的因果树。逻辑树的顶端就是我们要实现的需求、目的；因果树的叶子就是当前所有的现实、假设。现实需要实时关注他是否还存在; 假设需要实时关注他是否还成立。
所以架构设计就是在设计这棵因果树，这颗因果树其实就是我们的总设计图纸。衡量一个架构好坏的标准是：

1. 假设和现实的选取是否足够坚固稳定，这决定逻辑树是否需要频繁变更与大改
2. 逻辑树的每一层是否圆完整了，是否做到了使用/创造的概念最少。

在这里面就有两个关键点:
	
1. 假设的陷阱
2. 除了能做什么，更多的是不能做什么。

假设的陷阱主要是指假设具有不可枚举性：我们往往在设计的过程中因为头脑的惯性以及事物认识的程度不足导致我们并不知道自己依赖了那些假设。人没办法解决认知之外的事情（这些事情被称为'恍惚'），因此我们往往非常自然地就将他们'pass over in silence'了。比如日常我们使用日志模型定位超时类问题: A 服务调用 B 服务，A 调 B 超时了。通常，我们只要通过看 B 的日志，确实耗时很长，就可以认为 B 服务有问题。 但是从 B 的日志来看，这个请求很快就被处理完返回了。这个时候僵住了，该怎么分析呢？此时日志模型已经不够用了，得考虑日志模型依赖了哪些假设：

1. A 服务和 B 服务的计时系统都是准的，日志时间也是准的。
2. 内核没出问题，比如 A 和 B 在读写内核协议栈的时候，网络包都被及时收发出去了
3. A 和 B 之间网络没问题
4. ...

架构设计过程中除了说明白这么做搞得定之外（列清楚假设和依赖进行推导），还得说明为什么这么做是最好的、或者为什么别的更简单的做法搞不定，而这部分才是需要花费更多精力推敲清楚的内容。所以设计过程就像水流一样：这里堵住了绕一绕，那里堵住了绕一绕；这个地方有cpu空洞所以要多线程，那个地方有风险所以要集群拆分。这一切的一切的逻辑的现实，形成了系统的结构图的样子。所以程序员都喜欢约束：约束越多越明确，需要做的事情就越少。这也是说明了没有通用架构：

1. 每个企业的场景（组织架构、业务场景）都不一样，遇到问题也不一样
2. 人家做成所依赖的东西人家自己也不一定能搞得清楚说的明白

好和坏是同时产生的，每多一个功能就意味着堵上了未来的一条路。比如选择了自动内存回收的编程语言就意味着放弃了性能的把控力；选择了广告、弹窗的增加就意味着放弃了部分用户口碑。照搬人家的东西只会在得到不一定用得着的东西的情况下背负上更多的成本，当然这些你背上了也不一定自知：）。

学习架构其实就是学习历史：看看人家是在什么场景下怎么样解决了问题，背上了什么新的约束，踩了什么坑。否则仅仅是记住了这里有一个啥、哪里有一个啥，看起来很厉害，实际上没有太大意义。

成长就像是一个围城：做业务的同学觉得自己做的技术不够硬核、做基础架构的同学觉得自己的工作像在自嗨。不同团队的同学工作在这颗因果树的不同层次上，在我看来大多数人的工作大体是差不多的：在这颗因果树上你总有自己的上游和下游，除非你处于整体的最顶端（不好说是谁了）；或者你在整体的最底端（不知道是谁了）。打工人要做的事情就是把你这一层对依赖你的上一层撒的谎圆好了，圆的越完整越好。这可能也是厉害的人大概率做其他事也厉害的原因吧。

在这个过程中有一个前提：解决的问题必须是一个切实存在的问题，不然整个因果逻辑就会非常不坚固（因为怎么样似乎都行，实际怎么样都不行）。这是所谓'贵食母': 一定要溯源清楚做这件事的原本目的是什么，这意味着需要了解依赖你的人、事。不是因为技术需要而做，而是因为业务需要而做；不是因为同行有需要做，而是因为他确实会带来更好的体验而做;...。'反者道之动'，看不清、看错当前需要什么，事实的前进方向只会偏离自己的逾期。名被创造出来是为了解决问题的，仅仅追求名但是看不出来他解决什么问题是有问题的；看到了名后面的问题但是不是主要矛盾也是有问题的。

对于稳定性的保障，其实就是怎么保证这颗因果树不倒塌，顶层的节点的结论依然成立。从这个视角就能看得出这件事有多么的复杂和艰难。造东西可能很有趣，但是真不难：无非就是在这个因果树上加一些节点、替换一些节点。但是保障稳定性是你需要保证整个因果树时时刻刻成立，任意一个节点被破坏可能导致因果树坍塌，这个时候所有的细节脏东西都出来了，所有高大上的体系都不管用，所谓'当一切都回归于真实，所有的一切都不可挽回的沦于庸俗'（我估计安全也是这样）。我非常佩服做稳定性的同学，日复一日都兢兢业业的处理这些底下的细节，我自问我是比较难耐得住。大家通过各种智慧来维护因果树的可持续，比如:

1. 通过流程来规避认知的不足：设计的时候依赖没列清楚、或者因为人员流动把依赖的认知搞丢了。这里补充一下我不认为有人能把一个变更的影响评估清楚，即使变更'看起来'非常简单。历史已经无数次印证过了，1127不就是这么来的。
2. 兜底大招、降级：当因果树过于复杂或者捋不清楚的时候，在因果树上准备一个 B计划。在不知道直接原因时，链条断掉的时候还能临时补个支架上去
3. 控制变更，5条军规：每一个功能不仅堵上了未来的一条路，还可能破坏当前的因果。在知道直接原因的情况下，有办法能快速恢复回去。
4. ...
	
但是这里面还是有个悖论： 在看不清楚整个逻辑树的情况下，如何做得到稳定性措施能覆盖到整棵因果树？我认为这是做不到的，因此故障不能避免。只能：尽人事，听天命。地铁都能出故障你怎么保证软件这种东西不出故障。虽然这样，人事还是得尽的。当前我们每年都在进行运动式系统梳理，但是总归是有点难度：

1. 太难梳理。干这个事情的人得非常有经验，时刻能保持头脑清醒，不被时间所麻痹。事物只有进入到了人的认知才能被解决，而这个过程通常是被动的，依赖一些问题或前兆的出现。就好像有了丑才能有美，有了矮才能有高。反过来说：要是能被梳理出来我早就把事情解决了。
2. 当然，有些东西还是能被梳理出来的。有经验的人通过枚举个人的经历，经验不足的人依靠一定的灵感和运气：想起来小时候做数学题，不会做就一直盯着题目，就做出来了。问题是梳理出来的东西没办法可持续，没法维护。梳理的结果是一时的，系统会不断的发展。
	
理想情况下，稳定性保障角度看，技术团队还是需要有一个良好的工程文化，文化驱动细节。这个体现在:

1. 人。有良好的工程素养。逻辑的组织整理要贯穿：依赖列的全一些，因果逻辑梳理的完整一些，设计和实现一致一些，谎圆的好一些。后续维护节点如果有新的依赖或者发展也能补充到原来的设计中。团队和团队之间的设计也能互相有关联，最终形成一个总的设计图纸。就好像传统的工程一样，每次要做什么事也能先看看原来的设计图纸。
2. 工具。比较好的工具能够工帮助技术同学搞定上面这件事情。初步乍一想比如可以提出一些设计文档的范式，能将设计文档结构化管理起来：并和代码变动相关联。能达成看清是否动了某个条件，动了这个底层条件，影响了多少上层逻辑的效果。同时，也能通过结构化管理的依赖建立 fitness function，每当架构有变更的时候，还能检查架构的假设是否依然成立。
3. 组织。鼓励大家扎实地做好日常的工作，不激进做事，也不需要什么奖项、荣誉，让技术团队不为了所谓目标或名利而下赌注。对工作的鼓励体现在平时，润物细无声，行不言之教。尽可能保证人员稳定性，不仅是为了能更好的扶住现有的系统，也是让他每个技术工作都谨慎严肃对待，为整个系统，为自己的所作所为负责。
	



