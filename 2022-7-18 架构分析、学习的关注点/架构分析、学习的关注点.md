| 作者 | 版本号 | 时间 |
| :--- | :--- | :--- |
| Coordinate35 | v1.0.0 | 2022-07-18 |

# 架构分析、学习的关注点

写这篇文章是因为最近团队里面有个同学做的分享，感觉准备的不好，所以总结一下架构、学习的逻辑。

这位同学分享的主题是《Go 和 Nginx 的内存管理》，内容框架大概是这样的：
```
go和nginx的内存管理
- go的内存分配
  - 内存分配架构
  - 内存管理组件
    - 内存管理单元
    - 线程缓存
    - 中央缓存
    - 页堆
  - 虚拟内存布局
  - 内存分配流程
- go的内存回收
  - GC阶段
  - 触发条件
  - 三色标记法
  - 混合写屏障（1.8以后）
  - 业界GC优化方法
    - GO GC Tuner
    - Go Memory Ballast 
- go runtime总结
- nginx内存池
  - 数据结构：
  - 分配流程
  - 内存池销毁
- nginx slab共享内存管理
  - 数据结构
  - 分配流程
  - 与nginx内存池区别
```

这个组织方式有几个问题：
1. 逻辑链不完整，过快进到入细节：缺少了背景、这些方案要解决的问题、以及问题的分析
2. 没有完整的逻辑闭包。有多少个概念，这些概念的含义是什么，概念之间关系又是什么，是否已经达到了最少的状态。

名被发明出来是为了解决问题的。

《道德经》中有说："无，名天地之始；有，名万物之母。故常无，欲以观其妙；有，欲以观其徼"。如果一个系统常态下没有任何问题，我们完全不会关注到他：比如我们使用一个软件的时候，我们不会关注到这个软件是 Go 写的，还是 C 写的。 Go 和 C 的概念根本就不会在我脑海中诞生。但是一个软件它确实是某种语言写的，这个事实确实存在在这，这一切的事实对我而言都是恍惚，我并不关心。

当问题出现了，在这个场景下，“好”与“坏”才会成对的产生。比如我要做一个迭代频率非常高的软件，这个时候软件研发效率成了关键的度量，所以有自动内存回收的 Go 语言是更好的选择；倘若我要做一个性能要达到极致的软件，那无疑 C 语言是更好的选择。因此，一个东西怎么做是没有好坏之分的，只有在特定的问题、特定的场景下，我们带有一个特定的目的了，他才有好坏之分。

回到这位同学的分享内容：这位同学一上来就是 Go 的内存分配架构、管理组件。其实这些我们就无从判断这样做的合理性。中央缓存是啥？页堆是啥？这些名字被发明出来是解决什么问题，为什么这样是好的？在什么场景下有弊端？这些内容都需要在特定的背景，问题明确、目旳明确的场景下才能得知。

没有一个架构是绝对好的。所有的架构都是在特定目的下一个选择：因为好和坏是同时产生的。每做一个功能，都意味着堵上了未来的某一条路。我们分析和学习一个软件架构的时候，是学习:
1. 他们在什么场景、什么约束条件下做出了什么样的选择，学习他们分析、做选择的过程。
2. 为了解决这个问题，他构建的模型中有哪些假设、哪些概念？这些假设的可靠性如何？这些概念之间的关系是什么？这个模型是不是完备的，有没有破绽？在没有破绽的前提下，是不是已经做到了概念最少、依赖的假设最少。

缺少了这个分析，上来就 Go 这里有个啥，Nginx 那里有个啥，听起来很厉害的样子，实际上没有任何意义。

很多人在听分享的过程中、迷迷糊糊听不进去、听不懂，也就是由于这个逻辑链建立的不明晰，理不清其中的因果。

题外话：关于成长
很多人总是说自己要成长、做一个工作过程中要有自己的成长。这个成长到底是什么？有些人固化的觉得是人脉积累多了就是成长；有些人觉得工作经验的积累是成长。我的答案是和自己本心真正想活成啥样又关系。距离自己的目标更近了，就是成长了。这个东西的对立面是倒退，是和成长同时产生的。这个东西，和你是否想清楚了自己这辈子打算怎么过有关系。谁又能说的准，你今天所谓的“成长”，不会成为你明天的“桎梏”呢？
